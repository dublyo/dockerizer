package java

import (
	"context"
	"encoding/xml"
	"regexp"
	"strings"

	"github.com/dublyo/dockerizer/internal/scanner"
	"github.com/dublyo/dockerizer/providers"
)

// QuarkusProvider detects and generates Dockerfiles for Quarkus projects
type QuarkusProvider struct {
	providers.BaseProvider
}

// NewQuarkusProvider creates a new Quarkus provider
func NewQuarkusProvider() *QuarkusProvider {
	return &QuarkusProvider{
		BaseProvider: providers.BaseProvider{
			ProviderName:        "quarkus",
			ProviderLanguage:    "java",
			ProviderFramework:   "quarkus",
			ProviderTemplate:    "java/quarkus.tmpl",
			ProviderDescription: "Quarkus cloud-native Java framework",
			ProviderURL:         "https://quarkus.io",
		},
	}
}

// Detect checks if the repository is a Quarkus project
func (p *QuarkusProvider) Detect(ctx context.Context, scan *scanner.ScanResult) (int, map[string]interface{}, error) {
	score := 0
	vars := make(map[string]interface{})

	// Check for Maven (pom.xml) or Gradle (build.gradle)
	hasMaven := scan.FileTree.HasFile("pom.xml")
	hasGradle := scan.FileTree.HasFile("build.gradle") || scan.FileTree.HasFile("build.gradle.kts")

	if !hasMaven && !hasGradle {
		return 0, nil, nil
	}

	if hasMaven {
		vars["buildTool"] = "maven"
		score += p.detectMaven(scan, vars)
	} else if hasGradle {
		vars["buildTool"] = "gradle"
		score += p.detectGradle(scan, vars)
	}

	if score == 0 {
		return 0, nil, nil
	}

	// Check for Quarkus configuration files
	if scan.FileTree.HasFile("src/main/resources/application.properties") {
		data, err := scan.ReadFile("src/main/resources/application.properties")
		if err == nil {
			content := string(data)
			if strings.Contains(content, "quarkus.") {
				score += 10
			}
		}
	}

	if scan.FileTree.HasFile("src/main/resources/application.yaml") ||
		scan.FileTree.HasFile("src/main/resources/application.yml") {
		score += 5
	}

	// Check for mvnw or gradlew wrapper
	if scan.FileTree.HasFile("mvnw") {
		vars["hasWrapper"] = true
	} else if scan.FileTree.HasFile("gradlew") {
		vars["hasWrapper"] = true
	}

	// Check for native build support
	if scan.FileTree.HasFile("src/main/docker/Dockerfile.native") ||
		scan.FileTree.HasFile("src/main/docker/Dockerfile.native-micro") {
		vars["hasNativeSupport"] = true
	}

	// Check for Quarkus Dockerfiles (generated by Quarkus)
	if scan.FileTree.HasDir("src/main/docker") {
		vars["hasQuarkusDocker"] = true
	}

	// Detect Java version (if not already detected from build files)
	if _, ok := vars["javaVersion"]; !ok {
		vars["javaVersion"] = detectJavaVersionFromFiles(scan)
	}

	// Default port for Quarkus
	vars["port"] = "8080"

	// Cap at 100
	if score > 100 {
		score = 100
	}

	return score, vars, nil
}

// detectMaven parses pom.xml for Quarkus
func (p *QuarkusProvider) detectMaven(scan *scanner.ScanResult, vars map[string]interface{}) int {
	data, err := scan.ReadFile("pom.xml")
	if err != nil {
		return 0
	}

	content := string(data)
	score := 0

	// Check for Quarkus BOM or parent
	if strings.Contains(content, "io.quarkus") {
		score += 50
	}

	// Check for quarkus-bom
	if strings.Contains(content, "quarkus-bom") || strings.Contains(content, "quarkus-universe-bom") {
		score += 10
	}

	// Check for quarkus-maven-plugin
	if strings.Contains(content, "quarkus-maven-plugin") {
		score += 15
	}

	// Try to parse XML for more details
	var pom PomXML
	if err := xml.Unmarshal(data, &pom); err == nil {
		// Get Java version from properties
		if pom.Properties.JavaVersion != "" {
			vars["javaVersion"] = pom.Properties.JavaVersion
		}

		// Check dependencies
		for _, dep := range pom.Dependencies.Dependency {
			if dep.GroupID == "io.quarkus" {
				score += 5
				// Check for specific extensions
				if strings.Contains(dep.ArtifactID, "resteasy") {
					vars["hasResteasy"] = true
				}
				if strings.Contains(dep.ArtifactID, "hibernate") {
					vars["hasHibernate"] = true
				}
				if strings.Contains(dep.ArtifactID, "smallrye") {
					vars["hasSmallrye"] = true
				}
			}
		}
	}

	// Extract Quarkus version
	quarkusVersionRe := regexp.MustCompile(`<quarkus[.-]?(?:platform)?[.-]?version>([^<]+)</quarkus`)
	if matches := quarkusVersionRe.FindStringSubmatch(content); len(matches) > 1 {
		vars["quarkusVersion"] = matches[1]
	}

	return score
}

// detectGradle parses build.gradle for Quarkus
func (p *QuarkusProvider) detectGradle(scan *scanner.ScanResult, vars map[string]interface{}) int {
	var content string

	if scan.FileTree.HasFile("build.gradle.kts") {
		data, err := scan.ReadFile("build.gradle.kts")
		if err != nil {
			return 0
		}
		content = string(data)
	} else {
		data, err := scan.ReadFile("build.gradle")
		if err != nil {
			return 0
		}
		content = string(data)
	}

	score := 0

	// Check for Quarkus plugin
	if strings.Contains(content, "io.quarkus") {
		score += 50
	}

	// Check for quarkus platform
	if strings.Contains(content, "quarkus-universe-bom") || strings.Contains(content, "quarkus-bom") {
		score += 10
	}

	// Check for Quarkus dependencies
	if strings.Contains(content, "quarkus-resteasy") || strings.Contains(content, "quarkus-rest") {
		score += 10
		vars["hasResteasy"] = true
	}

	// Try to extract Java version
	if strings.Contains(content, "sourceCompatibility") || strings.Contains(content, "java.toolchain") {
		if strings.Contains(content, "21") {
			vars["javaVersion"] = "21"
		} else if strings.Contains(content, "17") {
			vars["javaVersion"] = "17"
		} else if strings.Contains(content, "11") {
			vars["javaVersion"] = "11"
		}
	}

	return score
}

// DetectVersion detects the Java version
func (p *QuarkusProvider) DetectVersion(scan *scanner.ScanResult) string {
	return detectJavaVersionFromFiles(scan)
}
